 Guide to Learning The Microcontroller Embedded System
Are you a young school student looking for study data to learn microcontrollers?Are you a high school / college student looking for information to design your microcontroller based project?Are you an old man planning to convert your old digital technology based design to a compact microcontroller based design?Are you working in an organization and want to upgrade your skills for microcontroller and embedded systemdesign?You all are from variety of age, expertise and skill levels. But your need is same. Your basic question is same.Your objective is same. That's to "Learn Microcontroller based design."You are on right track as you have decided to go along with microcontrollers for your all electronics projects.There is no other good method than using a microcontroller in product design.Here are the steps and information for you to get started:
1. Your knowledge and ability:
Every human is unique in the knowledge he has acquired and the abilities he has.Knowledge indicates the "experience"
 and ability indicate "time required to solve a design problem"e.g. I know C language very well
 but I can't solve a "Array Sorting program easily.
"This indicates having knowledge of C programming is not enough but one should have good ability to
 "Analyze and solve the problem statement".And this is the key and most important feature required while working with
any microcontroller based embeddeddesign system.In other word this ability to solve problems is called
 as "Logic of creating solutions"
  2. Hardware & Software
Microcontroller based embedded system designing is combination of hardware and software.Microcontroller is a small Integrated Chip (IC) and is the hardware part of the system. This small chip calledmicrocontroller has facility to store a "Program" inside it. This is called as software.You as a product designer, must have both expertise. Lets understand this by one example:"You have been assigned a simple task to design and develop a product to display room temperature.
 This project will need following components:1. The temperature sensor (e.g. LM35)2. A Microcontroller (e.g. ATmega8 AVR) to read the data from temperature sensor.3. A 16 chars by 2 lines (16x2) LCD display4. DC Voltage regulator 5V (7805 based)Once you have this set ready, then its time to create a circuit / schematics for this.Here is the point where you start learning about internals of microcontroller ATmega8.Learn the hardware aspect of this microcontroller and then the software. The software writing is using Assemblyor C Language.
3. Tools and equipments
A PC / Laptop, installed with IDE (development environment), ISP Programmer hardware, Starter kit / targetboard and some books or reference manuals or a Computer based Tutorial.In above example we have selected ATmega8 microcontroller. This is made by ATMEL and is from AVR family of controllers. This is 8 bit controller.WInAVR/ AVRstudio is used as IDE for writing program.There are many ISP programmers (hardware) available in the market.Starter kit helps you to experiment and test your program by downloading (flashing) the developed source codeinto the ATmega8 microcontroller.Books, reference manuals and Computer based tutorial will help you to get started with the new and excitingworld of microcontrollers.There are several other microcontrollers available like PIC, 8051, ARM, etc.Every family has some unique features to offer and you have to decide which feature you need the most.Cost of the microcontroller is also an important factor in selecting. Other factors but important are availability of tools like compilers, IDEs, starter kits, programmers, books and reference material.
 Atmel® offers both 8-bit and 32-bit AVR flash microcontrollers.
AVR combines the most code-efficient architecture for C and assembly programming with the ability to tunesystem parameters throughout the entire life cycle of your key products. No other microcontrollers deliver morecomputing performance at a lower power consumption. Combined with industry leading development tools anddesign support, you get to market faster. And once there, you can easily and cost-effectively refine and improveyour product offering.It’s simple: AVR works across the entire range of applications you’re working on, or want to work on.
32-bit AVR UC3
The 32-bit AVR UC3 product family is built on the high-performance 32-bit AVR architecture and optimized for highly integrated applications. The 32-bit AVR UC3 microcontrollers deliver high computational throughput,deterministic real-time control, low power consumption, low system cost, high reliability and ease of use. The 32-bit AVR CPU includes cutting-edge features such as integer and fixed point DSP arithmetic, single-cycle multiplyand accumulate instructions, and single-cycle SRAM access. The peripheral DMA controller and multi-layer high-speed bus architecture make the UC3 core ideal for high throughput applications. UC3 devices are perfectlysuited for portable and battery-powered applications due to their outstanding low power properties.
8/16-bit AVR XMEGA
The AVR XMEGA delivers 16-bit performance and leading low-power features at an 8-bit price point. With aPeripheral DMA controller, an innovative Peripheral Event System, crypto engine, and high-speed ADC andDAC, AVR XMEGA pushes the boundaries for high-performance 8/16-bit MCUs.All AVR XMEGA devices are compatible with tinyAVR and megaAVR devices. Within the XMEGA family, devicesare 100% code compatible across all devices from the smallest to the largest. This makes it possible to developwith any XMEGA device, and switch to any other XMEGA device later without having to change any code. Thisallows multi-project development teams to keep and maintain only one code base and use and re-use thisacross multiple projects. The result is much faster development and prototyping cycles.
 8-bit megaAVR 
The megaAVR family offers the broadest selection of devices and peripheral options, making them suitable for awide range of applications. The family contains devices with LCD, USB, CAN, and LIN interfaces, in addition tothe standard SPI, UART and I2C interface. Developed for applications that need large amount of program code,megaAVR offers substantial program and data memories. Better still, megaAVR features self-programming flashfor fast, secure, cost-effective field upgrades.
 8-bit tinyAVR 
tinyAVR devices are optimized for a wide range of applications that require a small but powerful microcontroller.They are perfect for size constrained applications and they are often found as glue logic in bigger systems.boards and is available with integrated A/D converter and EEPROM memory.By delivering Flash flexibility at Mask ROM prices, tinyAVR significantly cuts your time to market, while boostingyour bottom line. And there’s nothing tiny about that.
 Battery Management
The single-chip AVR battery management products cover the 1 to 4 Li-ion cells market. They feature dedicatedanalog-to-digital converters tailored for battery fuel gauging and voltage monitoring. Other MCU features includeindependent battery protection circuitry, voltage regulators, integrated cell balancing FETs, and special high-voltage I/O controlling charge and discharge.
AVR Microcontrollers - Introduction
It is believed the AVR basic architecture was conceived by two students at the Norwegian Institute of Technology(NTH) Alf-Egil Bogen and Vegard Wollan.The original AVR MCU was developed at a local ASIC house in Trondheim Norway, where the two founders of Atmel Norway were working as students. It was known as a uRISC (Micro RISC). When the technology was soldto Atmel, the internal architecture was further developed by Alf and Vegard at Atmel Norway, a subsidiary of Atmel founded by the two architects.The acronym AVR has been reported to stand for Advanced Virtual RISC, but it has also been rumoured to standfor the initials chip's designers: Alf and Vegard [RISC]. Atmel says that the name AVR is not an acronym anddoes not stand for anything in particular.Note that the use of "AVR" in this article generally refers to the 8-bit RISC line of Atmel AVR Microcontrollers.Among the first of the AVR line was the AT90S8515, which in a 40-pin DIP package has the same pinout as an8051 microcontroller, including the external multiplexed address and data bus. The polarity of the /RESET linewas opposite (8051's having an active-high RESET, while the AVR has an active-low /RESET), but other thanthat, the pinout was identical.
to maximize performance and parallelism, the AVR uses a
Harvard architecture
– with separate memories andbuses for program and data. Instructions in the program memory are executed with a single level pipelining.While one instruction is being exe- cuted, the next instruction is pre-fetched from the program memory. Thisconcept enables instructions to be executed in every clock cycle. The program memory is In- SystemReprogrammable Flash memory.
 Developing for the Atmel AVR Microcontroller on Linux
Whether you are creating a small Internet appliance, some hardware instrumentation, data loggers or an army of autonomous robots to do your bidding, in numerous situations you need the flexibility of a programmablecomputer. In many cases, a general-purpose system, such as the workhorse sitting under your desk, doesn'tmeet size, cost or power-consumption constraints and is simply overkill. What you need is a microcontroller.This article provides step-by-step instructions for setting up a complete development system for the Atmel AVRseries of microcontrollers, using free software and Linux. The detailed instructions provided here will allow you totransform your Linux system into a complete AVR development environment. This article walks you through allthe steps of building, debugging and installing a simple program.What Is a Microcontroller?When all the electronic components required to make a central processing unit (CPU)—instruction decoder,arithmetic/logic unit, registers and so on—are integrated into a single chip, you have a microprocessor. When, inturn, you bundle this CPU with supporting components, memory and I/O peripherals, you've got amicrocomputer. Extending the integration and miniaturization even further, you can combine all the elements of amicrocomputer onto a single integrated circuit—behold the microcontroller.The semiconductor industry evolves rapidly, making it difficult to provide an accurate and complete definition of the term microcontroller. Consider this: some microcontroller chips have capacities and clock speeds thatsurpass the 74KB of program memory and 4KB of RAM available to the 30kg Apollo Lunar Module computer.You can expect today's screamer PCs to be running tomorrow's embedded applications, with the definition of microcontroller shifting accordingly.Microcontrollers all have a microprocessor core, memory and I/O interfaces, and many have additionalperipherals onboard. The specific configuration of a particular chip influences its physical packaging, number of pins and cost. If you are accustomed to working with microcomputers, you may feel that microcontrollers aretight spots. They have a handful of kilobytes of program ROM and in the area of 256 bytes of RAM. Don't fretthough; a lot can be done in this space, as the MIT Instrumentation Lab demonstrated when developing theApollo Lunar Module software that controls its moon landing, return from the surface and rendezvous in orbit.AVR MicrocontrollersThe AVRs are 8-bit RISC platforms with a Harvard architecture (program and data memory are separate). Figure1 details the ATtiny26 AVR chip internal organization. Like each member of a family, it has its own particular combination of I/O and peripherals, but it shares a basic architecture and instruction set with all the other AVRs.The ATtiny26 has 2KB of program Flash memory, 128 bytes of onboard SRAM and EEPROM, two 8-bit countersand pulse-width modulators, 11 interrupts, 16 I/O pins spread over two 8-bit ports, an 11-channel 10-bit analog-to-digital converter and more—all on a single tiny 20-pin DIP.A number of factors make the AVR microcontrollers a good choice, especially for beginners. AVRs are:

Easy to code for: AVRs were designed from the ground up to allow easy and efficient programming inhigh-level languages, with a particular focus on C.

Easy to program: the combination of onboard reprogrammable Flash program memory and the in-system programming interface keeps the process of transferring software to the microcontroller simple
 
and cheap.

Powerful and inexpensive: AVRs pack a lot of power (1 MIPS/MHz, clocks up to 16MHz) and space (upto 128K of Flash program memory and 4K of EEPROM and SRAM) at low prices. Most AVRs eveninclude additional peripherals, such as UARTs and analog-to-digital converters.

Hobbyist-friendly: most of the chips in the AVR family come in easy-to-use 8-, 20-, 28- or 40-pin dual in-line packages (DIPs) and can be ordered in unit quantities from a number of distributors.

CPU
The processor core, composed of the components in the upper-left portion of Figure 1, includes elements to readthe program memory and to decode and execute the instructions within that memory. The CPU also can fetchand store data to and from the EEPROM, SRAM and the 32 registers. The registers act as extremely efficientstorage for 8-bit values (1 byte), and the ALU (arithmetic/logic unit) can operate directly on each of the 32registers. This AVR features a RAM-based stack. In a few other AVRs, which don't have any SRAM, the stack ishardware-based, limiting the stack depth to three.Most instructions take only a single clock cycle to execute, and there is no internal clock division on AVRs. TheCPU fetches and decodes the next instruction as it is executing the current instruction. These combined factsmean that AVRs can reach performances of nearly 1 MIPS (million instructions per second) per MHz. With clockrates of up to 16MHz, you can choose the right balance of speed, power consumption and electromagnetic noisefor your particular application.


Memory 
 Program space is a contiguous block of Flash memory, 16-bits wide that can be erased/rewritten 10,000 times.You can design your circuit to allow firmware upgrades in-circuit, using in-system programming.All AVRs have some EEPROM, and most have SRAM; both are 8-bits wide. The EEPROM is designed towithstand at least 100,000 erase/write cycles. EEPROM is useful because it can be written from within your embedded program to retain data, even without a power supply, or during programming, such as for production-line calibration.I/O and PeripheralsAll AVRs, from the tiny 8-pin DIPs to the 44-pin Megas, have at least one data port. Data ports allow for input or output of logic-level data. The AVR ports are bidirectional, allowing you to set them for input or output on a pin-by-pin basis.Many of the AVRs include additional hardware peripherals, such as UARTs for serial communication andcalibrated RC oscillators used as internal system clocks. The external pins often serve two or more purposes,and how they are used depends on how you've configured the microcontroller. For instance, Figure 1 shows thatcertain I/O lines from both ports can be used with the multiplexed A/D converter.Development Workstation SetupThe set of tools described here isn't the only one available, but it allows you to do basically anything, and thetools function well together. The toolkit is comprised of Binutils, GCC, AVR Libc and our Makefile template towrite and build programs for the AVR microcontrollers; GDB and simulavr to debug your software; and avrdudeas well as a hardware programmer to transfer your software to the microcontrollers. See the on-line Resourcesfor download URLs for all software.Fortunately, the recent versions of all these tools include support for the AVR platform, so installation isstraightforward. We assume you've chosen to install everything under /usr/local/AVR.BinutilsDownload a fresh copy of the current binutils source by following the link in the Resources. Untar the source,move into the binutils-X.XX directory and run:
$ ./configure --prefix=/usr/local/AVR --target=avr$ make# make install
The /usr/local/AVR/bin directory now contains AVR versions of ld, as, ar and the other binutils executables. Addthe /usr/local/AVR/bin directory to your PATH now. You can apply the modification system-wide by adding:
PATH="$PATH:/usr/local/AVR/bin"
to the /etc/profile file. Make sure the directory is in your PATH and that the change has taken effect beforeproceeding.GCCAfter retrieving a recent release of the Gnu Compiler Collection from a mirror, run the following commands fromwithin the unpacked top-level source directory:
$ ./configure --prefix=/usr/local/AVR \--target=avr --enable-languages="c,c++" \--disable-nls$ make# make install
This builds C and C++ compilers for AVR targets and installs avr-gcc and avr-g++ in /usr/local/AVR/bin.AVR LibcThe AVR Libc package provides a subset of the standard C library for AVR microcontrollers, including math, I/Oand string processing utilities. It also takes care of basic AVR startup procedures, such as initializing the interruptvector table, stack pointer and so forth. To install, get the latest release of the library and run the following from
 
the top-level source directory:
$ unset CC$ PREFIX=/usr/local/AVR ./doconf$ ./domake# ./domake install
Makefile TemplateThe Psychogenic team has created a standard Makefile template that simplifies AVR project management. Youcan customize it easily for all your assembly, C and C++ AVR projects.It provides everything for a host of make targets, from compilation and upload to the microcontroller to debugging aids, such as source code intermixedwith disassembly, and helpful gdbinit files. A detailed discussion of the template is available, and the Makefiletemplate is available as Listing 1 on the
Linux Journal 
FTP site (see Resources). Store the template with theother AVR tools, moving it to /usr/local/AVR/Makefile.tpl.GDB and SimulAVRUsing avr-gdb and simulavr in tandem, you can run your software on a choice of AVR microcontrollers throughthe simulator, while using GDB to step through and observe the executing code. Acquire the simulavr sourcefrom the project site and perform the installation:
$ ./configure --prefix=/usr/local/AVR \--with-avr-includes=/usr/local/AVR/avr/include$ make # make install
Install GDB, built for AVR targets, by compiling the source as follows:
$ ./configure --target=avr \--prefix=/usr/local/AVR$ make# make install
AVRDUDEWhen you finally have a program ready for testing on actual hardware, you need some way to upload the dataand write it to the microcontroller's Flash program memory. AVRDUDE and a compatible hardware programmer are the last components of the development kit. Grab a copy of the AVRDUDE source and install it with:
$ ./configure --prefix=/usr/local/AVR$ make# make install
You now have installed every software component required for a complete AVR development environment. Allyou need is the physical means to transfer programs to microcontrollers.AVRDUDE supports a number of different hardware programmer configurations. The simplest systems aredescribed on the AVRDUDE site and are comprised of little more than a parallel port connector, a ceramicoscillator and a DIP socket. These are powered directly off the computer's port and may not work for everyone.Debugging the ProgramA Makefile target that is interesting, whether for sanity checking, optimization, low-level debugging or simply toget to know the AVR internals, is disasm. Running:
$ make disasm
prints some information concerning theprogram, such as its text/data/bss size, to the console and creates helloavr.s. This file contains a disassembledversion of the executable, intermixed with the original C source code. A peek inside reveals AVR Libc and avr-gcc's work behind the scenes, initializing the interrupt vector table and data, followed by the Assembly and Cversions of the program.Now we use GDB as a source-level debugger with simulavr running as a remote target. To do so, launchsimulavr in the background and create a suitable gdbinit file:
$ simulavr --gdbserver --device at90s8515 &$ make gdbinit
 
Running
make
in this manner creates gdbinit-helloavr, a file containing instructions for setting up GDB correctly,such that it connects to a simulavr, loads the compiled program, inserts a breakpoint and begins execution.Launch avr-gdb using the command:
$ avr-gdb -x gdbinit-helloavr
and you are presented with the GDB prompt; program execution is halted before the first instruction in main().Set a breakpoint on line 71, using
b 71
, and enter C (continue) a few times. Every time you step over theinstruction on line 71:
71 PORTB = ~currentValue;
~currentValue is output through PORTB. You should see a message to that effect, for example,
writing 0xffto 0x0038
. When you are done, issue a
quit
and kill the simulavr process, which is running in thebackground.Installing the ProgramIf you've built or purchased the programmer hardware, you can install and test the software on a real AT90S8515chip. Configure the avrdude section in the Makefile by setting the AVRDUDE_PROGRAMMERID andAVRDUDE_PORT variables, as explained in the comments above. Use:
AVRDUDE_PROGRAMMERID=stk500AVRDUDE_PORT=/dev/ttyS0
for an STK500 programmer connected to the first serial port. Ensure that the programmer is connected to theappropriate port, insert the microcontroller in the programmer, apply power and type
make writeflash
. Thisgenerates the hex file used by AVRDUDE and writes its contents to the chip's Flash 
